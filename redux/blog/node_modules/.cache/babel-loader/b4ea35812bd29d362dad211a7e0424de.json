{"ast":null,"code":"import jsonPlaceholder from \"../api/jsonPlaceholder\";\n/**\n * Async/await syntax\n * When transpiled into ES5, results in a non-js plain object\n * being returned. This breaks the rules of redux, hence the\n * middleware alert error.\n *\n * If async/await not used, then fetch request still won't be\n * made by the time the function returns. Hence object's payload\n * will be undefined.\n */\n\nexport const fetchPosts = () => async dispatch => {\n  const response = await jsonPlaceholder.get(\"/posts\");\n  dispatch({\n    type: \"FETCH_POSTS\",\n    payload: response\n  });\n};\n/**\n * Redux-thunk allows async/await syntax as middleware only\n * handles the inner function, wrapped by the action creator.\n *\n * Once middle ware calls dispatch within the returned function\n * It passes the newly returned action, to the dispatch function\n * again, except this time with the proper payload from the AJAX\n * call.\n *\n * action creator (async) -> middleware -> dispatch -> reducers\n */\n\n/**\n * The above is equivalent to below. With a function returning\n * another function, the first curly braces and return statement\n * can be removed.\n *\n * export const fetchPosts = () => {\n *   return async dispatch => {\n *   const response = await jsonPlaceholder.get(\"/posts\");\n *\n *   dispatch({\n *     type: \"FETCH_POSTS\",\n *     payload: response\n *   });\n *  };\n * };\n */","map":{"version":3,"sources":["/Users/lucasbarbosa/Documents/MainDrive/Programming/JavaScript/react/redux/blog/src/actions/index.js"],"names":["jsonPlaceholder","fetchPosts","dispatch","response","get","type","payload"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,wBAA5B;AAEA;;;;;;;;;;;AAUA,OAAO,MAAMC,UAAU,GAAG,MAAM,MAAMC,QAAN,IAAkB;AAChD,QAAMC,QAAQ,GAAG,MAAMH,eAAe,CAACI,GAAhB,CAAoB,QAApB,CAAvB;AAEAF,EAAAA,QAAQ,CAAC;AACPG,IAAAA,IAAI,EAAE,aADC;AAEPC,IAAAA,OAAO,EAAEH;AAFF,GAAD,CAAR;AAID,CAPM;AASP;;;;;;;;;;;;AAYA","sourcesContent":["import jsonPlaceholder from \"../api/jsonPlaceholder\";\n\n/**\n * Async/await syntax\n * When transpiled into ES5, results in a non-js plain object\n * being returned. This breaks the rules of redux, hence the\n * middleware alert error.\n *\n * If async/await not used, then fetch request still won't be\n * made by the time the function returns. Hence object's payload\n * will be undefined.\n */\nexport const fetchPosts = () => async dispatch => {\n  const response = await jsonPlaceholder.get(\"/posts\");\n\n  dispatch({\n    type: \"FETCH_POSTS\",\n    payload: response\n  });\n};\n\n/**\n * Redux-thunk allows async/await syntax as middleware only\n * handles the inner function, wrapped by the action creator.\n *\n * Once middle ware calls dispatch within the returned function\n * It passes the newly returned action, to the dispatch function\n * again, except this time with the proper payload from the AJAX\n * call.\n *\n * action creator (async) -> middleware -> dispatch -> reducers\n */\n\n/**\n * The above is equivalent to below. With a function returning\n * another function, the first curly braces and return statement\n * can be removed.\n *\n * export const fetchPosts = () => {\n *   return async dispatch => {\n *   const response = await jsonPlaceholder.get(\"/posts\");\n *\n *   dispatch({\n *     type: \"FETCH_POSTS\",\n *     payload: response\n *   });\n *  };\n * };\n */\n"]},"metadata":{},"sourceType":"module"}