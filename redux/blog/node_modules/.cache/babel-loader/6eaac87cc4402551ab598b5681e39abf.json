{"ast":null,"code":"import _ from \"lodash\";\nimport jsonPlaceholder from \"../api/jsonPlaceholder\";\n/**\n * Async/await syntax\n * When transpiled into ES5, results in a non-js plain object\n * being returned. This breaks the rules of redux, hence the\n * middleware alert error.\n *\n * If async/await not used, then fetch request still won't be\n * made by the time the function returns. Hence object's payload\n * will be undefined.\n */\n\nexport const fetchPosts = () => async dispatch => {\n  const response = await jsonPlaceholder.get(\"/posts\");\n  dispatch({\n    type: \"FETCH_POSTS\",\n    payload: response.data\n  });\n};\n/**\n * Redux-thunk allows async/await syntax as middleware only\n * handles the inner function, wrapped by the action creator.\n *\n * Once middle ware calls dispatch within the returned function\n * It passes the newly returned action, to the dispatch function\n * again, except this time with the proper payload from the AJAX\n * call.\n *\n * action creator (async) -> middleware -> dispatch -> reducers\n */\n\n/**\n * The above is equivalent to below. With a function returning\n * another function, the first curly braces and return statement\n * can be removed.\n *\n * export const fetchPosts = () => {\n *   return async dispatch => {\n *   const response = await jsonPlaceholder.get(\"/posts\");\n *\n *   dispatch({\n *     type: \"FETCH_POSTS\",\n *     payload: response\n *   });\n *  };\n * };\n */\n// export const fetchUser = id => async dispatch => {\n//   const response = await jsonPlaceholder.get(`/users/${id}`);\n//   dispatch({\n//     type: \"FETCH_USER\",\n//     payload: response.data\n//   });\n// };\n// Cannot memoize whatever you like. The axios call will still be invoked\n// in both functions below\n\nexport const fetchUser = function (id) {\n  return async function (dispatch) {\n    const response = await jsonPlaceholder.get(`/users/${id}`);\n    dispatch({\n      type: \"FETCH_USER\",\n      payload: response.data\n    });\n  };\n};","map":{"version":3,"sources":["/Users/lucasbarbosa/Documents/MainDrive/Programming/JavaScript/react/redux/blog/src/actions/index.js"],"names":["_","jsonPlaceholder","fetchPosts","dispatch","response","get","type","payload","data","fetchUser","id"],"mappings":"AAAA,OAAOA,CAAP,MAAc,QAAd;AACA,OAAOC,eAAP,MAA4B,wBAA5B;AAEA;;;;;;;;;;;AAUA,OAAO,MAAMC,UAAU,GAAG,MAAM,MAAMC,QAAN,IAAkB;AAChD,QAAMC,QAAQ,GAAG,MAAMH,eAAe,CAACI,GAAhB,CAAoB,QAApB,CAAvB;AAEAF,EAAAA,QAAQ,CAAC;AACPG,IAAAA,IAAI,EAAE,aADC;AAEPC,IAAAA,OAAO,EAAEH,QAAQ,CAACI;AAFX,GAAD,CAAR;AAID,CAPM;AASP;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;;;AAiBA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA,OAAO,MAAMC,SAAS,GAAG,UAASC,EAAT,EAAa;AACpC,SAAO,gBAAeP,QAAf,EAAyB;AAC9B,UAAMC,QAAQ,GAAG,MAAMH,eAAe,CAACI,GAAhB,CAAqB,UAASK,EAAG,EAAjC,CAAvB;AAEAP,IAAAA,QAAQ,CAAC;AACPG,MAAAA,IAAI,EAAE,YADC;AAEPC,MAAAA,OAAO,EAAEH,QAAQ,CAACI;AAFX,KAAD,CAAR;AAID,GAPD;AAQD,CATM","sourcesContent":["import _ from \"lodash\";\nimport jsonPlaceholder from \"../api/jsonPlaceholder\";\n\n/**\n * Async/await syntax\n * When transpiled into ES5, results in a non-js plain object\n * being returned. This breaks the rules of redux, hence the\n * middleware alert error.\n *\n * If async/await not used, then fetch request still won't be\n * made by the time the function returns. Hence object's payload\n * will be undefined.\n */\nexport const fetchPosts = () => async dispatch => {\n  const response = await jsonPlaceholder.get(\"/posts\");\n\n  dispatch({\n    type: \"FETCH_POSTS\",\n    payload: response.data\n  });\n};\n\n/**\n * Redux-thunk allows async/await syntax as middleware only\n * handles the inner function, wrapped by the action creator.\n *\n * Once middle ware calls dispatch within the returned function\n * It passes the newly returned action, to the dispatch function\n * again, except this time with the proper payload from the AJAX\n * call.\n *\n * action creator (async) -> middleware -> dispatch -> reducers\n */\n\n/**\n * The above is equivalent to below. With a function returning\n * another function, the first curly braces and return statement\n * can be removed.\n *\n * export const fetchPosts = () => {\n *   return async dispatch => {\n *   const response = await jsonPlaceholder.get(\"/posts\");\n *\n *   dispatch({\n *     type: \"FETCH_POSTS\",\n *     payload: response\n *   });\n *  };\n * };\n */\n\n// export const fetchUser = id => async dispatch => {\n//   const response = await jsonPlaceholder.get(`/users/${id}`);\n\n//   dispatch({\n//     type: \"FETCH_USER\",\n//     payload: response.data\n//   });\n// };\n\n// Cannot memoize whatever you like. The axios call will still be invoked\n// in both functions below\nexport const fetchUser = function(id) {\n  return async function(dispatch) {\n    const response = await jsonPlaceholder.get(`/users/${id}`);\n\n    dispatch({\n      type: \"FETCH_USER\",\n      payload: response.data\n    });\n  };\n};\n"]},"metadata":{},"sourceType":"module"}